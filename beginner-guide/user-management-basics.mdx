---
title: "User Management in Banking Systems"
description: "Learn how customer accounts, authentication, and security work in Rails banking platform"
icon: "users"
---

# User Management in Banking Systems

Welcome to the world of banking user management! This guide will help you understand how to use Rails customer management APIs for building secure banking applications.

## What is User Management in Banking?

Think of user management like the **customer service desk of a bank**:

<Tabs>
  <Tab title="Traditional Banking">
    - **Identity Verification**: Check ID and documents
    - **Account Setup**: Create customer profiles
    - **Access Control**: Manage permissions and security
    - **Service Delivery**: Enable banking services
  </Tab>
  
  <Tab title="Rails Banking APIs">
    - **Customer Onboarding**: Create and verify customer profiles
    - **Authentication**: Secure login and token management
    - **Profile Management**: Update customer information
    - **Access Control**: Manage API permissions and scopes
  </Tab>
</Tabs>

**User Management = APIs that handle customer identity, authentication, and account access securely.**

## Rails Customer Management APIs

### üèõÔ∏è Enterprise-Grade Infrastructure
- **Proven Reliability**: 99.99% uptime with bank-grade infrastructure
- **Regulatory Compliance**: Meets KYC, AML, and banking regulations
- **Global Scale**: Handles millions of customers worldwide
- **Security First**: SOC 2 Type II certified with end-to-end encryption

### üöÄ Developer-Friendly Design  
- **RESTful APIs**: Industry-standard HTTP endpoints
- **Comprehensive SDKs**: Pre-built clients for popular languages
- **Real-time Webhooks**: Instant notifications for customer events
- **Sandbox Environment**: Safe testing without real data

<Note>
**For Developers**: Rails handles all the complex banking compliance and security requirements, so you can focus on building great customer experiences.
</Note>

## Core Customer Management APIs

### 1. Customer Creation API

```javascript Create Customer
// POST /v1/customers
const customerData = {
  first_name: "John",
  last_name: "Doe",
  email: "john.doe@example.com",
  phone: "+1-555-0123",
  date_of_birth: "1990-01-15",
  address: {
    street: "123 Main St",
    city: "Anytown", 
    state: "CA",
    zip_code: "90210"
  }
};

const response = await fetch('https://api.rails.com/v1/customers', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer your_api_key',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(customerData)
});

const customer = await response.json();
```

```json Response Format
{
  "customer_id": "cust_abc123",
  "first_name": "John",
  "last_name": "Doe",
  "email": "john.doe@example.com",
  "phone": "+1-555-0123", 
  "status": "active",
  "kyc_status": "pending",
  "created_at": "2024-01-15T10:30:00Z",
  "updated_at": "2024-01-15T10:30:00Z"
}
```

**What this API provides:**
- **Unique customer ID**: Permanent identifier for the customer
- **KYC tracking**: Know Your Customer compliance status
- **Status management**: Active, pending, suspended, or closed
- **Audit trail**: Complete history of customer interactions

### 2. Customer Retrieval API

```javascript Get Customer
// GET /v1/customers/{customer_id}
const response = await fetch('https://api.rails.com/v1/customers/cust_abc123', {
  headers: {
    'Authorization': 'Bearer your_api_key',
    'Content-Type': 'application/json'
  }
});

const customer = await response.json();
```

```javascript List Customers
// GET /v1/customers with filtering and pagination
const params = new URLSearchParams({
  status: 'active',
  kyc_status: 'verified',
  limit: '50',
  starting_after: 'cust_xyz789'
});

const response = await fetch(`https://api.rails.com/v1/customers?${params}`, {
  headers: {
    'Authorization': 'Bearer your_api_key'
  }
});

const customerList = await response.json();
```

```json Customer List Response
{
  "data": [
    {
      "customer_id": "cust_abc123",
      "first_name": "John",
      "last_name": "Doe",
      "email": "john.doe@example.com",
      "status": "active",
      "kyc_status": "verified"
    }
  ],
  "has_more": true,
  "next_cursor": "cust_def456"
}
```

**API Features:**
- **Efficient pagination**: Handle large customer lists easily
- **Flexible filtering**: Find customers by status, KYC, date ranges
- **Consistent responses**: Standardized format across all endpoints
- **Performance optimized**: Sub-100ms response times globally

### 3. Customer Update API

```javascript Update Customer
// PUT /v1/customers/{customer_id}
const updates = {
  phone: "+1-555-9999",
  address: {
    street: "456 Oak Ave",
    city: "New City",
    state: "NY", 
    zip_code: "10001"
  }
};

const response = await fetch('https://api.rails.com/v1/customers/cust_abc123', {
  method: 'PUT',
  headers: {
    'Authorization': 'Bearer your_api_key',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(updates)
});
```

```javascript Customer Status Management
// PATCH /v1/customers/{customer_id}/status
const statusUpdate = {
  status: "suspended",
  reason: "Account under review",
  effective_date: "2024-01-20T00:00:00Z"
};

const response = await fetch('https://api.rails.com/v1/customers/cust_abc123/status', {
  method: 'PATCH',
  headers: {
    'Authorization': 'Bearer your_api_key',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(statusUpdate)
});
```

```json Status Update Response
{
  "customer_id": "cust_abc123",
  "status": "suspended",
  "previous_status": "active",
  "reason": "Account under review",
  "effective_date": "2024-01-20T00:00:00Z",
  "updated_at": "2024-01-15T14:30:00Z"
}
```

## Authentication Flow (How Customer Login Works)

Let's trace what happens when a customer authenticates with your banking app:

<Steps>
  <Step title="Customer initiates login">
    ```javascript
    // Your app calls Rails authentication API
    const loginData = {
      email: "alice@example.com",
      password: "SecurePassword123!",
      device_fingerprint: "mobile_ios_15.1"
    };
    
    const response = await fetch('https://api.rails.com/v1/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(loginData)
    });
    ```
  </Step>
  
  <Step title="Rails validates credentials securely">
    Rails handles all security validation behind the scenes:
    - Verifies email and password against encrypted records
    - Checks account status (active, suspended, etc.)  
    - Validates device and location for fraud prevention
    - Enforces rate limiting and brute force protection
  </Step>
  
  <Step title="Rails returns authentication token">
    ```json
    {
      "access_token": "rails_token_abc123xyz...",
      "customer_id": "cust_alice_789",
      "expires_in": 3600,
      "token_type": "Bearer",
      "scopes": ["accounts:read", "transfers:create"]
    }
    ```
  </Step>
  
  <Step title="Your app uses token for API calls">
    ```javascript
    // Store token securely (never in localStorage for banking!)
    await secureTokenStorage.store('auth_token', response.access_token);
    
    // Use token for all subsequent API calls
    const headers = {
      'Authorization': `Bearer ${response.access_token}`,
      'Content-Type': 'application/json'
    };
    ```
  </Step>
</Steps>

## Security Features in Rails Customer Management

### üîê Multi-Factor Authentication

```javascript Enable MFA for Customer
// POST /v1/customers/{customer_id}/mfa/enable
const mfaSetup = {
  method: "sms", // or "totp", "email"
  phone: "+1-555-0123"
};

const response = await fetch('https://api.rails.com/v1/customers/cust_abc123/mfa/enable', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer your_api_key',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(mfaSetup)
});
```

```javascript Verify MFA Code
// POST /v1/auth/mfa/verify
const verification = {
  customer_id: "cust_abc123",
  code: "123456",
  method: "sms"
};

const response = await fetch('https://api.rails.com/v1/auth/mfa/verify', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer temp_token_xyz',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(verification)
});
```

**Security Benefits:**
- **Bank-grade encryption**: All data encrypted in transit and at rest
- **PCI DSS compliance**: Meets payment card industry standards  
- **SOC 2 certified**: Independently audited security controls
- **Fraud detection**: Real-time monitoring for suspicious activities

### üõ°Ô∏è API Token Security

```javascript Token Management
// Rails automatically handles secure token generation
// Your app just needs to use the tokens properly

// Refresh expired tokens
const refreshResponse = await fetch('https://api.rails.com/v1/auth/refresh', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer your_refresh_token',
    'Content-Type': 'application/json'
  }
});

const newTokens = await refreshResponse.json();
```

```javascript Revoke Token (Logout)
// POST /v1/auth/logout
const response = await fetch('https://api.rails.com/v1/auth/logout', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer current_token',
    'Content-Type': 'application/json'
  }
});

// Token is now invalid and cannot be used
```

```json Token Validation Response  
{
  "valid": true,
  "customer_id": "cust_abc123",
  "expires_at": "2024-01-15T15:30:00Z",
  "scopes": ["accounts:read", "transfers:create"],
  "issued_at": "2024-01-15T14:30:00Z"
}
```

### üè¢ Multi-Tenant Access Control

Rails provides secure multi-tenant architecture for banking organizations:

```javascript Organization Management
// GET /v1/organizations/{org_id}/customers
const customers = await fetch('https://api.rails.com/v1/organizations/org_123/customers', {
  headers: {
    'Authorization': 'Bearer your_api_key',
    'X-Rails-Organization': 'org_123'
  }
});

// Each organization's data is completely isolated
```

```javascript Environment Separation
// Sandbox environment for testing
const sandboxResponse = await fetch('https://api.sandbox.rails.com/v1/customers', {
  headers: {
    'Authorization': 'Bearer sandbox_key_test123'
  }
});

// Production environment for live data  
const prodResponse = await fetch('https://api.rails.com/v1/customers', {
  headers: {
    'Authorization': 'Bearer prod_key_live456'
  }
});
```

**Access Control Features:**
- **Data Isolation**: Complete separation between organizations
- **Role-Based Access**: Admin, operator, and read-only permissions
- **Environment Separation**: Sandbox and production environments
- **API Key Scoping**: Granular permission control per integration

## Customer Onboarding Process (Step by Step)

### 1. Customer Registration API

```javascript Customer Registration
// POST /v1/customers - Create new customer
const customerData = {
  first_name: "Alice",
  last_name: "Johnson", 
  email: "alice.johnson@example.com",
  phone: "+1-555-0123",
  date_of_birth: "1985-03-15",
  address: {
    street: "123 Main Street",
    city: "San Francisco",
    state: "CA", 
    zip_code: "94105",
    country: "US"
  },
  identity_verification: {
    ssn_last_4: "1234",
    document_type: "drivers_license", 
    document_number: "DL123456789"
  }
};

const response = await fetch('https://api.rails.com/v1/customers', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer your_api_key',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(customerData)
});
```

```json Registration Response
{
  "customer_id": "cust_alice_abc123",
  "status": "pending_verification",
  "kyc_status": "documents_required",
  "verification_url": "https://verify.rails.com/cust_alice_abc123",
  "required_documents": ["government_id", "proof_of_address"],
  "created_at": "2024-01-15T10:30:00Z"
}
```

### 2. KYC (Know Your Customer) Process

```javascript Document Upload
// POST /v1/customers/{customer_id}/documents
const formData = new FormData();
formData.append('type', 'government_id');
formData.append('document', driversLicenseFile);

const uploadResponse = await fetch('https://api.rails.com/v1/customers/cust_alice_abc123/documents', {
  method: 'POST', 
  headers: {
    'Authorization': 'Bearer your_api_key'
  },
  body: formData
});
```

```javascript Check Verification Status
// GET /v1/customers/{customer_i

### 3. Event-Driven Communication

When a user is created, Rails publishes events to other services:

```java rails/mvp/api/users/event/UserCreatedEvent.java#L1-20
public class UserCreatedEvent {
    private final Long userId;
    private final String email;
    private final Long organizationId;
    private final UserRole role;
    private final Instant timestamp;
    
    public UserCreatedEvent(Long userId, String email, Long organizationId, UserRole role) {
        this.userId = userId;
        this.email = email;
        this.organizationId = organizationId;
        this.role = role;
        this.timestamp = Instant.now();
    }
    
    // This event gets sent to NATS message system
    // Other services (like Accounts) can listen and react
}
```

## Common User Management Patterns

### 1. Idempotency (Preventing Duplicate Operations)

```java rails/mvp/api/users/service/IdempotencyService.java#L1-35
@Service
public class IdempotencyService {
    
    private final IdempotencyKeyRepository repository;
    
    public void checkIdempotency(String key, String operation) {
        Optional<IdempotencyKey> existing = repository.findByKey(key);
        
        if (existing.isPresent()) {
            if (existing.get().getOperation().equals(operation)) {
                // Same operation with same key - return previous result
                throw new DuplicateOperationException(existing.get().getResponseBody());
            } else {
                // Same key, different operation - reject
                throw new IdempotencyKeyMismatchException();
            }
        }
        
        // First time seeing this key - save it
        IdempotencyKey idempotencyKey = new IdempotencyKey();
        idempotencyKey.setKey(key);
        idempotencyKey.setOperation(operation);
        idempotencyKey.setStatus("PROCESSING");
        repository.save(idempotencyKey);
    }
}
```

**Why this matters:**
- **Prevents duplicate users**: If network fails, retrying won't create duplicates
- **Financial accuracy**: Critical in banking where duplicate accounts = big problems
- **Client-friendly**: Apps can safely retry failed requests

### 2. Soft Delete (Keeping Data for Compliance)

```java rails/mvp/api/users/model/User.java#L50-65
@Entity
public class User {
    // ... other fields ...
    
    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
    
    // Soft delete - mark as deleted but keep in database
    public void softDelete() {
        this.deletedAt = LocalDateTime.now();
        this.status = UserStatus.DELETED;
    }
    
    // Check if user is active (not deleted)
    public boolean isActive() {
        return deletedAt == null && status == UserStatus.ACTIVE;
    }
}
```

**Banking requirement:**
- **Regulatory compliance**: Must keep customer records for auditing
- **Transaction integrity**: Can't delete users with transaction history
- **Recovery option**: Can restore accidentally deleted accounts

## Testing User Management

### Unit Tests (Testing Individual Components)

```java rails/mvp/api/users/test/UserServiceTest.java#L1-40
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    @Mock
    private PasswordService passwordService;
    
    @InjectMocks
    private UserService userService;
    
    @Test
    void createUser_ShouldCreateUserSuccessfully() {
        // Given
        CreateUserRequest request = new CreateUserRequest();
        request.setEmail("test@example.com");
        request.setFirstName("John");
        request.setLastName("Doe");
        request.setPassword("SecurePassword123!");
        
        when(userRepository.existsByEmail("test@example.com")).thenReturn(false);
        when(passwordService.hashPassword("SecurePassword123!")).thenReturn("$2a$10$...");
        
        User savedUser = new User();
        savedUser.setId(1L);
        savedUser.setEmail("test@example.com");
        when(userRepository.save(any(User.class))).thenReturn(savedUser);
        
        // When
        User result = userService.createUser(request, "idempotency-key-123");
        
        // Then
        assertThat(result.getId()).isEqualTo(1L);
        assertThat(result.getEmail()).isEqualTo("test@example.com");
        verify(userRepository).save(any(User.class));
    }
}
```

### Integration Tests (Testing the Full API)

```java rails/mvp/api/users/test/UserControllerIntegrationTest.java#L1-45
@SpringBootTest
@AutoConfigureTestDatabase
@TestMethodOrder(OrderAnnotation.class)
class UserControllerIntegrationTest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    @Order(1)
    void createUser_ShouldReturn201Created() {
        // Given
        CreateUserRequest request = new CreateUserRequest();
        request.setFirstName("Alice");
        request.setLastName("Johnson");
        request.setEmail("alice@example.com");
        request.setPassword("VerySecurePassword123!");
        request.setOrganizationId(1L);
        
        HttpHeaders headers = new HttpHeaders();
        headers.set("Idempotency-Key", "test-key-123");
        headers.set("Content-Type", "application/json");
        
        HttpEntity<CreateUserRequest> entity = new HttpEntity<>(request, headers);
        
        // When
        ResponseEntity<UserResponse> response = restTemplate.exchange(
            "/api/users",
            HttpMethod.POST,
            entity,
            UserResponse.class
        );
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);
        assertThat(response.getBody().getEmail()).isEqualTo("alice@example.com");
        
        // Verify user was saved to database
        Optional<User> savedUser = userRepository.findByEmail("alice@example.com");
        assertThat(savedUser).isPresent();
    }
}
```

## Real-World Example: Mobile Banking Registration

Let's see how all these pieces work together when someone registers for mobile banking:

<CodeGroup>
```javascript Mobile App (Frontend)
// User fills out registration form
const registerUser = async (formData) => {
  try {
    const response = await fetch('/api/users', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Idempotency-Key': generateUniqueKey(),
        'X-Organization-Code': 'MYBANK001'
      },
      body: JSON.stringify({
        firstName: formData.firstName,
        lastName: formData.lastName,
        email: formData.email,
        password: formData.password,
        phoneNumber: formData.phone
      })
    });
    
    if (response.ok) {
      const user = await response.json();
      // Registration successful - redirect to login
      window.location.href = '/login';
    } else {
      const error = await response.json();
      showError(error.message);
    }
  } catch (error) {
    showError('Registration failed. Please try again.');
  }
};
```

```java Spring Boot (Backend)
@PostMapping
public ResponseEntity<UserResponse> createUser(
    @Valid @RequestBody CreateUserRequest request,
    @RequestHeader("Idempotency-Key") String idempotencyKey,
    @RequestHeader("X-Organization-Code") String orgCode
) {
    // 1. Find organization by code
    Organization org = organizationService.findByCode(orgCode);
    request.setOrganizationId(org.getId());
    
    // 2. Check for duplicate operations
    idempotencyService.checkIdempotency(idempotencyKey, "CREATE_USER");
    
    // 3. Create user account
    User user = userService.createUser(request, idempotencyKey);
    
    // 4. Send welcome email (async)
    emailService.sendWelcomeEmail(user.getEmail(), user.getFirstName());
    
    // 5. Trigger account creation in other services
    eventPublisher.publishEvent(new UserCreatedEvent(user));
    
    // 6. Return success response
    UserResponse response = UserResponse.fromUser(user);
    return ResponseEntity.status(HttpStatus.CREATED).body(response);
}
```
</CodeGroup>

## Common Challenges and Solutions

<Accordion>
  <AccordionItem title="Challenge: Password Reset Security">
    **Problem**: How to safely reset passwords without compromising security?
    
    **Solution**: Multi-step verification process
    ```java
    @Service
    public class PasswordResetService {
        
        public void requestPasswordReset(String email) {
            User user = userRepository.findByEmail(email).orElseThrow();
            
            // Generate secure token with expiration
            String resetToken = UUID.randomUUID().toString();
            
            PasswordResetToken token = new PasswordResetToken();
            token.setToken(resetToken);
            token.setUserId(user.getId());
            token.setExpiresAt(LocalDateTime.now().plusHours(1)); // 1 hour expiry
            resetTokenRepository.save(token);
            
            // Send secure email with reset link
            emailService.sendPasswordResetEmail(user.getEmail(), resetToken);
        }
    }
    ```
  </AccordionItem>
  
  <AccordionItem title="Challenge: Account Lockout Protection">
    **Problem**: Prevent brute force attacks while not locking out legitimate users
    
    **Solution**: Progressive delay with account lockout
    ```java
    @Service
    public class LoginAttemptService {
        
        private final Map<String, Integer> attempts = new ConcurrentHashMap<>();
        
        public void recordFailedLogin(String email) {
            attempts.merge(email, 1, Integer::sum);
            
            int failedAttempts = attempts.get(email);
            if (failedAttempts >= 5) {
                // Lock account and notify user
                userService.lockAccount(email);
                emailService.sendSecurityAlert(email);
            }
        }
        
        public boolean isBlocked(String email) {
            return attempts.getOrDefault(email, 0) >= 5;
        }
    }
    ```
  </AccordionItem>
  
  <AccordionItem title="Challenge: GDPR Compliance (Right to be Forgotten)">
    **Problem**: Users can request complete data deletion under GDPR
    
    **Solution**: Data anonymization while preserving financial records
    ```java
    @Service
    public class GdprService {
        
        public void anonymizeUser(Long userId) {
            User user = userRepository.findById(userId).orElseThrow();
            
            // Keep user record but remove personal data
            user.setFirstName("DELETED");
            user.setLastName("USER"); 
            user.setEmail("deleted-" + UUID.randomUUID() + "@example.com");
            user.setPhoneNumber(null);
            user.setMetadata("{}"); // Clear personal metadata
            user.setGdprDeleted(true);
            
            userRepository.save(user);
            
            // Keep transaction records for regulatory compliance
            // but remove personal identifiers
        }
    }
    ```
  </AccordionItem>
</Accordion>

## Next Steps

Now that you understand user management, you're ready to explore:

<CardGroup cols={2}>
  <Card
    title="Account Management Basics"
    icon="wallet"
    href="/beginner-guide/account-management-basics"
  >
    Learn how bank accounts, balances, and transactions work in Rust
  </Card>
  
  <Card
    title="API Security Deep Dive"
    icon="shield"
    href="/beginner-guide/api-security-basics"
  >
    Understand JWT, OAuth, and banking-grade security measures
  </Card>
  
  <Card
    title="Build Your First Banking App"
    icon="code"
    href="/beginner-guide/first-project-setup"
  >
    Step-by-step tutorial to create a simple banking application
  </Card>
  
  <Card
    title="Spring Boot for Banking"
    icon="coffee"
    href="/beginner-guide/spring-boot-banking"
  >
    Advanced patterns and best practices for financial applications
  </Card>
</CardGroup>

## Key Takeaways

<Note>
**Remember These Core Concepts:**

1. **User Management is the Foundation** - Everything else in banking depends on secure, reliable user management

2. **Security is Paramount** - Hash passwords, validate inputs, use secure tokens, and always audit access

3. **Java + Spring Boot = Banking Standard** - Mature, reliable, and trusted by financial institutions worldwide

4. **Organization-Based Architecture** - Multi-tenancy allows one system to serve multiple banks or business units

5. **Event-Driven Design** - User actions trigger events that other services can respond to

6. **Idempotency Matters** - In banking, being able to safely retry operations is crucial

**Most Important**: Start with security in mind, not as an afterthought. Banking applications handle people's life savings - that's a huge responsibility!
</Note>

Ready to learn about account management and how money moves through the system? Let's dive into the Rust-powered Accounts service! üöÄ